// Autogenerated from Pigeon (v13.1.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func createConnectionError(withChannelName channelName: String) -> FlutterError {
  return FlutterError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum EventKitCalendarAuthorizationStatus: Int {
  case notDetermined = 0
  case restricted = 1
  case denied = 2
  case authorized = 3
}

enum EventKitEventAvailability: Int {
  case notSupported = 0
  case busy = 1
  case free = 2
  case tentative = 3
  case unavailable = 4
}

enum EventKitEventStatus: Int {
  case none = 0
  case confirmed = 1
  case tentative = 2
  case canceled = 3
}

enum EventKitRecurrenceFrequency: Int {
  case daily = 0
  case weekly = 1
  case monthly = 2
  case yearly = 3
}

/// Generated class from Pigeon that represents data sent in messages.
struct EventKitDateTime {
  var year: Int64
  var month: Int64
  var day: Int64
  var hour: Int64
  var minute: Int64
  var second: Int64
  var millisecond: Int64

  static func fromList(_ list: [Any?]) -> EventKitDateTime? {
    let year = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let month = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let day = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)
    let hour = list[3] is Int64 ? list[3] as! Int64 : Int64(list[3] as! Int32)
    let minute = list[4] is Int64 ? list[4] as! Int64 : Int64(list[4] as! Int32)
    let second = list[5] is Int64 ? list[5] as! Int64 : Int64(list[5] as! Int32)
    let millisecond = list[6] is Int64 ? list[6] as! Int64 : Int64(list[6] as! Int32)

    return EventKitDateTime(
      year: year,
      month: month,
      day: day,
      hour: hour,
      minute: minute,
      second: second,
      millisecond: millisecond
    )
  }
  func toList() -> [Any?] {
    return [
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct EventKitCalendar {
  var identifier: String
  var title: String
  var source: String? = nil
  var color: String? = nil
  var isEditable: Bool
  var isSubscribed: Bool
  var externalId: String? = nil

  static func fromList(_ list: [Any?]) -> EventKitCalendar? {
    let identifier = list[0] as! String
    let title = list[1] as! String
    let source: String? = nilOrValue(list[2])
    let color: String? = nilOrValue(list[3])
    let isEditable = list[4] as! Bool
    let isSubscribed = list[5] as! Bool
    let externalId: String? = nilOrValue(list[6])

    return EventKitCalendar(
      identifier: identifier,
      title: title,
      source: source,
      color: color,
      isEditable: isEditable,
      isSubscribed: isSubscribed,
      externalId: externalId
    )
  }
  func toList() -> [Any?] {
    return [
      identifier,
      title,
      source,
      color,
      isEditable,
      isSubscribed,
      externalId,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct EventKitEvent {
  var identifier: String? = nil
  var title: String
  var notes: String? = nil
  var startDate: EventKitDateTime
  var endDate: EventKitDateTime
  var isAllDay: Bool
  var location: String? = nil
  var url: String? = nil
  var availability: EventKitEventAvailability
  var status: EventKitEventStatus
  var calendarId: String? = nil
  var attendeeEmails: [String?]? = nil
  var recurrenceRule: EventKitRecurrenceRule? = nil

  static func fromList(_ list: [Any?]) -> EventKitEvent? {
    let identifier: String? = nilOrValue(list[0])
    let title = list[1] as! String
    let notes: String? = nilOrValue(list[2])
    let startDate = EventKitDateTime.fromList(list[3] as! [Any?])!
    let endDate = EventKitDateTime.fromList(list[4] as! [Any?])!
    let isAllDay = list[5] as! Bool
    let location: String? = nilOrValue(list[6])
    let url: String? = nilOrValue(list[7])
    let availability = EventKitEventAvailability(rawValue: list[8] as! Int)!
    let status = EventKitEventStatus(rawValue: list[9] as! Int)!
    let calendarId: String? = nilOrValue(list[10])
    let attendeeEmails: [String?]? = nilOrValue(list[11])
    var recurrenceRule: EventKitRecurrenceRule? = nil
    if let recurrenceRuleList: [Any?] = nilOrValue(list[12]) {
      recurrenceRule = EventKitRecurrenceRule.fromList(recurrenceRuleList)
    }

    return EventKitEvent(
      identifier: identifier,
      title: title,
      notes: notes,
      startDate: startDate,
      endDate: endDate,
      isAllDay: isAllDay,
      location: location,
      url: url,
      availability: availability,
      status: status,
      calendarId: calendarId,
      attendeeEmails: attendeeEmails,
      recurrenceRule: recurrenceRule
    )
  }
  func toList() -> [Any?] {
    return [
      identifier,
      title,
      notes,
      startDate.toList(),
      endDate.toList(),
      isAllDay,
      location,
      url,
      availability.rawValue,
      status.rawValue,
      calendarId,
      attendeeEmails,
      recurrenceRule?.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct EventKitReminder {
  var identifier: String? = nil
  var title: String
  var notes: String? = nil
  var dueDate: EventKitDateTime? = nil
  var completionDate: EventKitDateTime? = nil
  var isCompleted: Bool
  var calendarId: String? = nil
  var priority: Int64? = nil

  static func fromList(_ list: [Any?]) -> EventKitReminder? {
    let identifier: String? = nilOrValue(list[0])
    let title = list[1] as! String
    let notes: String? = nilOrValue(list[2])
    var dueDate: EventKitDateTime? = nil
    if let dueDateList: [Any?] = nilOrValue(list[3]) {
      dueDate = EventKitDateTime.fromList(dueDateList)
    }
    var completionDate: EventKitDateTime? = nil
    if let completionDateList: [Any?] = nilOrValue(list[4]) {
      completionDate = EventKitDateTime.fromList(completionDateList)
    }
    let isCompleted = list[5] as! Bool
    let calendarId: String? = nilOrValue(list[6])
    let priority: Int64? = isNullish(list[7]) ? nil : (list[7] is Int64? ? list[7] as! Int64? : Int64(list[7] as! Int32))

    return EventKitReminder(
      identifier: identifier,
      title: title,
      notes: notes,
      dueDate: dueDate,
      completionDate: completionDate,
      isCompleted: isCompleted,
      calendarId: calendarId,
      priority: priority
    )
  }
  func toList() -> [Any?] {
    return [
      identifier,
      title,
      notes,
      dueDate?.toList(),
      completionDate?.toList(),
      isCompleted,
      calendarId,
      priority,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct EventKitRecurrenceRule {
  var frequency: EventKitRecurrenceFrequency
  var interval: Int64
  var endDate: EventKitDateTime? = nil
  var occurrenceCount: Int64? = nil
  var daysOfTheWeek: [Int64?]? = nil
  var daysOfTheMonth: [Int64?]? = nil
  var monthsOfTheYear: [Int64?]? = nil

  static func fromList(_ list: [Any?]) -> EventKitRecurrenceRule? {
    let frequency = EventKitRecurrenceFrequency(rawValue: list[0] as! Int)!
    let interval = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    var endDate: EventKitDateTime? = nil
    if let endDateList: [Any?] = nilOrValue(list[2]) {
      endDate = EventKitDateTime.fromList(endDateList)
    }
    let occurrenceCount: Int64? = isNullish(list[3]) ? nil : (list[3] is Int64? ? list[3] as! Int64? : Int64(list[3] as! Int32))
    let daysOfTheWeek: [Int64?]? = nilOrValue(list[4])
    let daysOfTheMonth: [Int64?]? = nilOrValue(list[5])
    let monthsOfTheYear: [Int64?]? = nilOrValue(list[6])

    return EventKitRecurrenceRule(
      frequency: frequency,
      interval: interval,
      endDate: endDate,
      occurrenceCount: occurrenceCount,
      daysOfTheWeek: daysOfTheWeek,
      daysOfTheMonth: daysOfTheMonth,
      monthsOfTheYear: monthsOfTheYear
    )
  }
  func toList() -> [Any?] {
    return [
      frequency.rawValue,
      interval,
      endDate?.toList(),
      occurrenceCount,
      daysOfTheWeek,
      daysOfTheMonth,
      monthsOfTheYear,
    ]
  }
}

private class EventKitHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return EventKitCalendar.fromList(self.readValue() as! [Any?])
      case 129:
        return EventKitCalendar.fromList(self.readValue() as! [Any?])
      case 130:
        return EventKitDateTime.fromList(self.readValue() as! [Any?])
      case 131:
        return EventKitEvent.fromList(self.readValue() as! [Any?])
      case 132:
        return EventKitEvent.fromList(self.readValue() as! [Any?])
      case 133:
        return EventKitRecurrenceRule.fromList(self.readValue() as! [Any?])
      case 134:
        return EventKitReminder.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class EventKitHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? EventKitCalendar {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitCalendar {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitDateTime {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitEvent {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitEvent {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitRecurrenceRule {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitReminder {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class EventKitHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return EventKitHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return EventKitHostApiCodecWriter(data: data)
  }
}

class EventKitHostApiCodec: FlutterStandardMessageCodec {
  static let shared = EventKitHostApiCodec(readerWriter: EventKitHostApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol EventKitHostApi {
  func requestCalendarAccess(completion: @escaping (Result<Bool, Error>) -> Void)
  func getCalendarAuthorizationStatus(completion: @escaping (Result<EventKitCalendarAuthorizationStatus, Error>) -> Void)
  func getCalendars(completion: @escaping (Result<[EventKitCalendar], Error>) -> Void)
  func getCalendar(identifier: String, completion: @escaping (Result<EventKitCalendar?, Error>) -> Void)
  func getEvents(startDate: EventKitDateTime, endDate: EventKitDateTime, calendarIdentifiers: [String]?, completion: @escaping (Result<[EventKitEvent], Error>) -> Void)
  func getEvent(identifier: String, completion: @escaping (Result<EventKitEvent?, Error>) -> Void)
  func saveEvent(event: EventKitEvent, completion: @escaping (Result<String, Error>) -> Void)
  func removeEvent(identifier: String, completion: @escaping (Result<Bool, Error>) -> Void)
  func getReminders(predicate: String?, completion: @escaping (Result<[EventKitReminder], Error>) -> Void)
  func saveReminder(reminder: EventKitReminder, completion: @escaping (Result<String, Error>) -> Void)
  func removeReminder(identifier: String, completion: @escaping (Result<Bool, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class EventKitHostApiSetup {
  /// The codec used by EventKitHostApi.
  static var codec: FlutterStandardMessageCodec { EventKitHostApiCodec.shared }
  /// Sets up an instance of `EventKitHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: EventKitHostApi?) {
    let requestCalendarAccessChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.requestCalendarAccess", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      requestCalendarAccessChannel.setMessageHandler { _, reply in
        api.requestCalendarAccess() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      requestCalendarAccessChannel.setMessageHandler(nil)
    }
    let getCalendarAuthorizationStatusChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getCalendarAuthorizationStatus", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCalendarAuthorizationStatusChannel.setMessageHandler { _, reply in
        api.getCalendarAuthorizationStatus() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res.rawValue))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getCalendarAuthorizationStatusChannel.setMessageHandler(nil)
    }
    let getCalendarsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getCalendars", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCalendarsChannel.setMessageHandler { _, reply in
        api.getCalendars() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getCalendarsChannel.setMessageHandler(nil)
    }
    let getCalendarChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getCalendar", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCalendarChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! String
        api.getCalendar(identifier: identifierArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getCalendarChannel.setMessageHandler(nil)
    }
    let getEventsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getEvents", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEventsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let startDateArg = args[0] as! EventKitDateTime
        let endDateArg = args[1] as! EventKitDateTime
        let calendarIdentifiersArg: [String]? = nilOrValue(args[2])
        api.getEvents(startDate: startDateArg, endDate: endDateArg, calendarIdentifiers: calendarIdentifiersArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getEventsChannel.setMessageHandler(nil)
    }
    let getEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getEvent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! String
        api.getEvent(identifier: identifierArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getEventChannel.setMessageHandler(nil)
    }
    let saveEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.saveEvent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! EventKitEvent
        api.saveEvent(event: eventArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      saveEventChannel.setMessageHandler(nil)
    }
    let removeEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.removeEvent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! String
        api.removeEvent(identifier: identifierArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      removeEventChannel.setMessageHandler(nil)
    }
    let getRemindersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getReminders", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getRemindersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let predicateArg: String? = nilOrValue(args[0])
        api.getReminders(predicate: predicateArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getRemindersChannel.setMessageHandler(nil)
    }
    let saveReminderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.saveReminder", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveReminderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let reminderArg = args[0] as! EventKitReminder
        api.saveReminder(reminder: reminderArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      saveReminderChannel.setMessageHandler(nil)
    }
    let removeReminderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.removeReminder", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeReminderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! String
        api.removeReminder(identifier: identifierArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      removeReminderChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol EventKitFlutterApiProtocol {
  func onCalendarAccessChanged(status statusArg: EventKitCalendarAuthorizationStatus, completion: @escaping (Result<Void, FlutterError>) -> Void)
  func onEventsChanged(completion: @escaping (Result<Void, FlutterError>) -> Void)
}
class EventKitFlutterApi: EventKitFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  func onCalendarAccessChanged(status statusArg: EventKitCalendarAuthorizationStatus, completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_event_kit.EventKitFlutterApi.onCalendarAccessChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger)
    channel.sendMessage([statusArg.rawValue] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName:channelName)))
        return
      }
      if (listResponse.count > 1) {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)));
      } else {
        completion(.success(Void()))
      }
    }
  }
  func onEventsChanged(completion: @escaping (Result<Void, FlutterError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.flutter_event_kit.EventKitFlutterApi.onEventsChanged"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger)
    channel.sendMessage(nil) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName:channelName)))
        return
      }
      if (listResponse.count > 1) {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(FlutterError(code: code, message: message, details: details)));
      } else {
        completion(.success(Void()))
      }
    }
  }
}
private class CalendarHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return EventKitCalendar.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class CalendarHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? EventKitCalendar {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class CalendarHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CalendarHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CalendarHostApiCodecWriter(data: data)
  }
}

class CalendarHostApiCodec: FlutterStandardMessageCodec {
  static let shared = CalendarHostApiCodec(readerWriter: CalendarHostApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CalendarHostApi {
  func getCalendars(completion: @escaping (Result<[EventKitCalendar], Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class CalendarHostApiSetup {
  /// The codec used by CalendarHostApi.
  static var codec: FlutterStandardMessageCodec { CalendarHostApiCodec.shared }
  /// Sets up an instance of `CalendarHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: CalendarHostApi?) {
    let getCalendarsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.CalendarHostApi.getCalendars", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCalendarsChannel.setMessageHandler { _, reply in
        api.getCalendars() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getCalendarsChannel.setMessageHandler(nil)
    }
  }
}
private class EventHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return EventKitDateTime.fromList(self.readValue() as! [Any?])
      case 129:
        return EventKitEvent.fromList(self.readValue() as! [Any?])
      case 130:
        return EventKitEvent.fromList(self.readValue() as! [Any?])
      case 131:
        return EventKitRecurrenceRule.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class EventHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? EventKitDateTime {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitEvent {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitEvent {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitRecurrenceRule {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class EventHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return EventHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return EventHostApiCodecWriter(data: data)
  }
}

class EventHostApiCodec: FlutterStandardMessageCodec {
  static let shared = EventHostApiCodec(readerWriter: EventHostApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol EventHostApi {
  func getEvents(startDate: EventKitDateTime, endDate: EventKitDateTime, calendarIdentifiers: [String]?, completion: @escaping (Result<[EventKitEvent], Error>) -> Void)
  func getEvent(identifier: String, completion: @escaping (Result<EventKitEvent?, Error>) -> Void)
  func saveEvent(event: EventKitEvent, completion: @escaping (Result<String, Error>) -> Void)
  func removeEvent(identifier: String, completion: @escaping (Result<Bool, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class EventHostApiSetup {
  /// The codec used by EventHostApi.
  static var codec: FlutterStandardMessageCodec { EventHostApiCodec.shared }
  /// Sets up an instance of `EventHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: EventHostApi?) {
    let getEventsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventHostApi.getEvents", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEventsChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let startDateArg = args[0] as! EventKitDateTime
        let endDateArg = args[1] as! EventKitDateTime
        let calendarIdentifiersArg: [String]? = nilOrValue(args[2])
        api.getEvents(startDate: startDateArg, endDate: endDateArg, calendarIdentifiers: calendarIdentifiersArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getEventsChannel.setMessageHandler(nil)
    }
    let getEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventHostApi.getEvent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! String
        api.getEvent(identifier: identifierArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getEventChannel.setMessageHandler(nil)
    }
    let saveEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventHostApi.saveEvent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let eventArg = args[0] as! EventKitEvent
        api.saveEvent(event: eventArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      saveEventChannel.setMessageHandler(nil)
    }
    let removeEventChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.EventHostApi.removeEvent", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeEventChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! String
        api.removeEvent(identifier: identifierArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      removeEventChannel.setMessageHandler(nil)
    }
  }
}
private class ReminderHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return EventKitDateTime.fromList(self.readValue() as! [Any?])
      case 129:
        return EventKitReminder.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class ReminderHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? EventKitDateTime {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? EventKitReminder {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class ReminderHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return ReminderHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return ReminderHostApiCodecWriter(data: data)
  }
}

class ReminderHostApiCodec: FlutterStandardMessageCodec {
  static let shared = ReminderHostApiCodec(readerWriter: ReminderHostApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol ReminderHostApi {
  func getReminders(predicate: String?, completion: @escaping (Result<[EventKitReminder], Error>) -> Void)
  func saveReminder(reminder: EventKitReminder, completion: @escaping (Result<String, Error>) -> Void)
  func removeReminder(identifier: String, completion: @escaping (Result<Bool, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class ReminderHostApiSetup {
  /// The codec used by ReminderHostApi.
  static var codec: FlutterStandardMessageCodec { ReminderHostApiCodec.shared }
  /// Sets up an instance of `ReminderHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: ReminderHostApi?) {
    let getRemindersChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.ReminderHostApi.getReminders", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getRemindersChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let predicateArg: String? = nilOrValue(args[0])
        api.getReminders(predicate: predicateArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getRemindersChannel.setMessageHandler(nil)
    }
    let saveReminderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.ReminderHostApi.saveReminder", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      saveReminderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let reminderArg = args[0] as! EventKitReminder
        api.saveReminder(reminder: reminderArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      saveReminderChannel.setMessageHandler(nil)
    }
    let removeReminderChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_event_kit.ReminderHostApi.removeReminder", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      removeReminderChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let identifierArg = args[0] as! String
        api.removeReminder(identifier: identifierArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      removeReminderChannel.setMessageHandler(nil)
    }
  }
}
