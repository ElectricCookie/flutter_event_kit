// Autogenerated from Pigeon (v13.1.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

List<Object?> wrapResponse({Object? result, PlatformException? error, bool empty = false}) {
  if (empty) {
    return <Object?>[];
  }
  if (error == null) {
    return <Object?>[result];
  }
  return <Object?>[error.code, error.message, error.details];
}

enum EventKitCalendarAuthorizationStatus {
  notDetermined,
  restricted,
  denied,
  authorized,
}

enum EventKitEventAvailability {
  notSupported,
  busy,
  free,
  tentative,
  unavailable,
}

enum EventKitEventStatus {
  none,
  confirmed,
  tentative,
  canceled,
}

enum EventKitRecurrenceFrequency {
  daily,
  weekly,
  monthly,
  yearly,
}

class EventKitDateTime {
  EventKitDateTime({
    required this.year,
    required this.month,
    required this.day,
    required this.hour,
    required this.minute,
    required this.second,
    required this.millisecond,
  });

  int year;

  int month;

  int day;

  int hour;

  int minute;

  int second;

  int millisecond;

  Object encode() {
    return <Object?>[
      year,
      month,
      day,
      hour,
      minute,
      second,
      millisecond,
    ];
  }

  static EventKitDateTime decode(Object result) {
    result as List<Object?>;
    return EventKitDateTime(
      year: result[0]! as int,
      month: result[1]! as int,
      day: result[2]! as int,
      hour: result[3]! as int,
      minute: result[4]! as int,
      second: result[5]! as int,
      millisecond: result[6]! as int,
    );
  }
}

class EventKitCalendar {
  EventKitCalendar({
    required this.identifier,
    required this.title,
    this.source,
    this.color,
    required this.isEditable,
    required this.isSubscribed,
    this.externalId,
  });

  String identifier;

  String title;

  String? source;

  String? color;

  bool isEditable;

  bool isSubscribed;

  String? externalId;

  Object encode() {
    return <Object?>[
      identifier,
      title,
      source,
      color,
      isEditable,
      isSubscribed,
      externalId,
    ];
  }

  static EventKitCalendar decode(Object result) {
    result as List<Object?>;
    return EventKitCalendar(
      identifier: result[0]! as String,
      title: result[1]! as String,
      source: result[2] as String?,
      color: result[3] as String?,
      isEditable: result[4]! as bool,
      isSubscribed: result[5]! as bool,
      externalId: result[6] as String?,
    );
  }
}

class EventKitEvent {
  EventKitEvent({
    this.identifier,
    required this.title,
    this.notes,
    required this.startDate,
    required this.endDate,
    required this.isAllDay,
    this.location,
    this.url,
    required this.availability,
    required this.status,
    this.calendarId,
    this.attendeeEmails,
    this.recurrenceRule,
  });

  String? identifier;

  String title;

  String? notes;

  EventKitDateTime startDate;

  EventKitDateTime endDate;

  bool isAllDay;

  String? location;

  String? url;

  EventKitEventAvailability availability;

  EventKitEventStatus status;

  String? calendarId;

  List<String?>? attendeeEmails;

  EventKitRecurrenceRule? recurrenceRule;

  Object encode() {
    return <Object?>[
      identifier,
      title,
      notes,
      startDate.encode(),
      endDate.encode(),
      isAllDay,
      location,
      url,
      availability.index,
      status.index,
      calendarId,
      attendeeEmails,
      recurrenceRule?.encode(),
    ];
  }

  static EventKitEvent decode(Object result) {
    result as List<Object?>;
    return EventKitEvent(
      identifier: result[0] as String?,
      title: result[1]! as String,
      notes: result[2] as String?,
      startDate: EventKitDateTime.decode(result[3]! as List<Object?>),
      endDate: EventKitDateTime.decode(result[4]! as List<Object?>),
      isAllDay: result[5]! as bool,
      location: result[6] as String?,
      url: result[7] as String?,
      availability: EventKitEventAvailability.values[result[8]! as int],
      status: EventKitEventStatus.values[result[9]! as int],
      calendarId: result[10] as String?,
      attendeeEmails: (result[11] as List<Object?>?)?.cast<String?>(),
      recurrenceRule: result[12] != null
          ? EventKitRecurrenceRule.decode(result[12]! as List<Object?>)
          : null,
    );
  }
}

class EventKitReminder {
  EventKitReminder({
    this.identifier,
    required this.title,
    this.notes,
    this.dueDate,
    this.completionDate,
    required this.isCompleted,
    this.calendarId,
    this.priority,
  });

  String? identifier;

  String title;

  String? notes;

  EventKitDateTime? dueDate;

  EventKitDateTime? completionDate;

  bool isCompleted;

  String? calendarId;

  int? priority;

  Object encode() {
    return <Object?>[
      identifier,
      title,
      notes,
      dueDate?.encode(),
      completionDate?.encode(),
      isCompleted,
      calendarId,
      priority,
    ];
  }

  static EventKitReminder decode(Object result) {
    result as List<Object?>;
    return EventKitReminder(
      identifier: result[0] as String?,
      title: result[1]! as String,
      notes: result[2] as String?,
      dueDate: result[3] != null
          ? EventKitDateTime.decode(result[3]! as List<Object?>)
          : null,
      completionDate: result[4] != null
          ? EventKitDateTime.decode(result[4]! as List<Object?>)
          : null,
      isCompleted: result[5]! as bool,
      calendarId: result[6] as String?,
      priority: result[7] as int?,
    );
  }
}

class EventKitRecurrenceRule {
  EventKitRecurrenceRule({
    required this.frequency,
    required this.interval,
    this.endDate,
    this.occurrenceCount,
    this.daysOfTheWeek,
    this.daysOfTheMonth,
    this.monthsOfTheYear,
  });

  EventKitRecurrenceFrequency frequency;

  int interval;

  EventKitDateTime? endDate;

  int? occurrenceCount;

  List<int?>? daysOfTheWeek;

  List<int?>? daysOfTheMonth;

  List<int?>? monthsOfTheYear;

  Object encode() {
    return <Object?>[
      frequency.index,
      interval,
      endDate?.encode(),
      occurrenceCount,
      daysOfTheWeek,
      daysOfTheMonth,
      monthsOfTheYear,
    ];
  }

  static EventKitRecurrenceRule decode(Object result) {
    result as List<Object?>;
    return EventKitRecurrenceRule(
      frequency: EventKitRecurrenceFrequency.values[result[0]! as int],
      interval: result[1]! as int,
      endDate: result[2] != null
          ? EventKitDateTime.decode(result[2]! as List<Object?>)
          : null,
      occurrenceCount: result[3] as int?,
      daysOfTheWeek: (result[4] as List<Object?>?)?.cast<int?>(),
      daysOfTheMonth: (result[5] as List<Object?>?)?.cast<int?>(),
      monthsOfTheYear: (result[6] as List<Object?>?)?.cast<int?>(),
    );
  }
}

class _EventKitHostApiCodec extends StandardMessageCodec {
  const _EventKitHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is EventKitCalendar) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is EventKitCalendar) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is EventKitDateTime) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is EventKitEvent) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is EventKitEvent) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is EventKitRecurrenceRule) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is EventKitReminder) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return EventKitCalendar.decode(readValue(buffer)!);
      case 129: 
        return EventKitCalendar.decode(readValue(buffer)!);
      case 130: 
        return EventKitDateTime.decode(readValue(buffer)!);
      case 131: 
        return EventKitEvent.decode(readValue(buffer)!);
      case 132: 
        return EventKitEvent.decode(readValue(buffer)!);
      case 133: 
        return EventKitRecurrenceRule.decode(readValue(buffer)!);
      case 134: 
        return EventKitReminder.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class EventKitHostApi {
  /// Constructor for [EventKitHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  EventKitHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _EventKitHostApiCodec();

  Future<bool> requestCalendarAccess() async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.requestCalendarAccess';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<EventKitCalendarAuthorizationStatus> getCalendarAuthorizationStatus() async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getCalendarAuthorizationStatus';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return EventKitCalendarAuthorizationStatus.values[replyList[0]! as int];
    }
  }

  Future<List<EventKitCalendar?>> getCalendars() async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getCalendars';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<EventKitCalendar?>();
    }
  }

  Future<EventKitCalendar?> getCalendar(String arg_identifier) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getCalendar';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_identifier]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return (replyList[0] as EventKitCalendar?);
    }
  }

  Future<List<EventKitEvent?>> getEvents(EventKitDateTime arg_startDate, EventKitDateTime arg_endDate, List<String?>? arg_calendarIdentifiers) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getEvents';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_startDate, arg_endDate, arg_calendarIdentifiers]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<EventKitEvent?>();
    }
  }

  Future<EventKitEvent?> getEvent(String arg_identifier) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getEvent';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_identifier]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return (replyList[0] as EventKitEvent?);
    }
  }

  Future<String> saveEvent(EventKitEvent arg_event) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.saveEvent';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_event]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<bool> removeEvent(String arg_identifier) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.removeEvent';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_identifier]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<List<EventKitReminder?>> getReminders(String? arg_predicate) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.getReminders';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_predicate]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<EventKitReminder?>();
    }
  }

  Future<String> saveReminder(EventKitReminder arg_reminder) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.saveReminder';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_reminder]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<bool> removeReminder(String arg_identifier) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventKitHostApi.removeReminder';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_identifier]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }
}

abstract class EventKitFlutterApi {
  static const MessageCodec<Object?> codec = StandardMessageCodec();

  void onCalendarAccessChanged(EventKitCalendarAuthorizationStatus status);

  void onEventsChanged();

  static void setup(EventKitFlutterApi? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_event_kit.EventKitFlutterApi.onCalendarAccessChanged', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.flutter_event_kit.EventKitFlutterApi.onCalendarAccessChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final EventKitCalendarAuthorizationStatus? arg_status = args[0] == null ? null : EventKitCalendarAuthorizationStatus.values[args[0]! as int];
          assert(arg_status != null,
              'Argument for dev.flutter.pigeon.flutter_event_kit.EventKitFlutterApi.onCalendarAccessChanged was null, expected non-null EventKitCalendarAuthorizationStatus.');
          try {
            api.onCalendarAccessChanged(arg_status!);
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.flutter_event_kit.EventKitFlutterApi.onEventsChanged', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          try {
            api.onEventsChanged();
            return wrapResponse(empty: true);
          } on PlatformException catch (e) {
            return wrapResponse(error: e);
          }          catch (e) {
            return wrapResponse(error: PlatformException(code: 'error', message: e.toString()));
          }
        });
      }
    }
  }
}

class _CalendarHostApiCodec extends StandardMessageCodec {
  const _CalendarHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is EventKitCalendar) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return EventKitCalendar.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class CalendarHostApi {
  /// Constructor for [CalendarHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CalendarHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _CalendarHostApiCodec();

  Future<List<EventKitCalendar?>> getCalendars() async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.CalendarHostApi.getCalendars';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<EventKitCalendar?>();
    }
  }
}

class _EventHostApiCodec extends StandardMessageCodec {
  const _EventHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is EventKitDateTime) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is EventKitEvent) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is EventKitEvent) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is EventKitRecurrenceRule) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return EventKitDateTime.decode(readValue(buffer)!);
      case 129: 
        return EventKitEvent.decode(readValue(buffer)!);
      case 130: 
        return EventKitEvent.decode(readValue(buffer)!);
      case 131: 
        return EventKitRecurrenceRule.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class EventHostApi {
  /// Constructor for [EventHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  EventHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _EventHostApiCodec();

  Future<List<EventKitEvent?>> getEvents(EventKitDateTime arg_startDate, EventKitDateTime arg_endDate, List<String?>? arg_calendarIdentifiers) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventHostApi.getEvents';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_startDate, arg_endDate, arg_calendarIdentifiers]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<EventKitEvent?>();
    }
  }

  Future<EventKitEvent?> getEvent(String arg_identifier) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventHostApi.getEvent';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_identifier]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return (replyList[0] as EventKitEvent?);
    }
  }

  Future<String> saveEvent(EventKitEvent arg_event) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventHostApi.saveEvent';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_event]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<bool> removeEvent(String arg_identifier) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.EventHostApi.removeEvent';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_identifier]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }
}

class _ReminderHostApiCodec extends StandardMessageCodec {
  const _ReminderHostApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is EventKitDateTime) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is EventKitReminder) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return EventKitDateTime.decode(readValue(buffer)!);
      case 129: 
        return EventKitReminder.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class ReminderHostApi {
  /// Constructor for [ReminderHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ReminderHostApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ReminderHostApiCodec();

  Future<List<EventKitReminder?>> getReminders(String? arg_predicate) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.ReminderHostApi.getReminders';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_predicate]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<EventKitReminder?>();
    }
  }

  Future<String> saveReminder(EventKitReminder arg_reminder) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.ReminderHostApi.saveReminder';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_reminder]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as String?)!;
    }
  }

  Future<bool> removeReminder(String arg_identifier) async {
    const String channelName = 'dev.flutter.pigeon.flutter_event_kit.ReminderHostApi.removeReminder';
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
      channelName,
      codec,
      binaryMessenger: _binaryMessenger,
    );
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_identifier]) as List<Object?>?;
    if (replyList == null) {
      throw _createConnectionError(channelName);
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }
}
